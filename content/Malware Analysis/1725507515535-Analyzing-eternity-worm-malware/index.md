---
title: "Analyzing Eternity wrom malware (Eternity Group)"
date: 2024-09-05
draft: false
description: "Analyzing Eternity wrom malware from Eternity Project"
tags: ["Eternity malware", "Malware Analysis", "worm"]
---



## Artifacts:

### Eternity Worm Stage 1:

![image](/images/malware-analysis/eternity-worm/2.png)

### Static Analysis:

This sample of Eternity Worm has an icon of an image to deceive naïve users especially if the file extension was hidden, and it's a good trick because further down the analysis we see that after running the assumed to be an image (malware) it will run an image from its resources to hide its execution:

![image](/images/malware-analysis/eternity-worm/3.png)

Throwing the sample on"Detect It Easy" we find that it's .NET obfuscated sample as it appear from the ".text" section:

![image](/images/malware-analysis/eternity-worm/4.png)

## Unpacking The Malware:

Running the sample in "dnspy" we can see that it is heavily obfuscated and very similar to "Eternity Stealer" malware. So I used "de4dote" to deobfuscate and clean the sample :

![image](/images/malware-analysis/eternity-worm/5.png)

![image](/images/malware-analysis/eternity-worm/6.png)

![image](/images/malware-analysis/eternity-worm/7.png)

From the cleaned version image above, we can see that the loader will get its resources, and it will start by loading the encrypted image and its key, then decrypt it with a simple decryption routine and run it. Also, do the same with the worm executable and exit after executing it:

![image](/images/malware-analysis/eternity-worm/8.png)

![image](/images/malware-analysis/eternity-worm/9.png)

To Get the decrypted malware sample, we set a breakpoint after the decryption routine and then save the buffer that holds the malware with the right extension and we will get a working sample:

![image](/images/malware-analysis/eternity-worm/10.png)

![image](/images/malware-analysis/eternity-worm/11.png)

Or using python we can decrypt resource files after saving it:

![image](/images/malware-analysis/eternity-worm/12.png)

![image](/images/malware-analysis/eternity-worm/13.png)

## Eternity Worm Stage 2:

Geo-fencing:
The Eternity Worm start by enumerating the languages on the machine and if it found that the machine has a Ukrainian language, it will print the message "Glory to Ukraine" and exit, otherwise it will continue execution:

![image](/images/malware-analysis/eternity-worm/14.png)

## Anti-Repeating:

This feature is not a core functionality of the malware, it's added base on the buyer's choice. The malware will check if there was "- -debug" string in the command line argument, and if it found nothing, it will create a named object/Mutex with the name "nwwqwdpozq". Failing to create the Mutex will cause the exit of the process, otherwise the execution will continue:

![image](/images/malware-analysis/eternity-worm/15.png)

## File Fetching & C2 communication:

Downloaded files:
"hxxp[://]soapbeginshops[.]com/kingz[.]exe"
"hxxp[://]soapbeginshops[.]com/ItsMe[.]zip"
"hxxp[://]lightnogu5owjjllyo4tj2sfos6fchnmcidlgo6c7e6fz2hgryhfhoyd[.]onion[.]pet/shared/telegram[.]exe"

We can also capture the requests with Wireshark and Fakenet :

![image](/images/malware-analysis/eternity-worm/16.png)

![image](/images/malware-analysis/eternity-worm/17.png)

![image](/images/malware-analysis/eternity-worm/18.png)

![image](/images/malware-analysis/eternity-worm/19.png)

![image](/images/malware-analysis/eternity-worm/20.png)

## Spreading Techniques:

### 1 - Telegram spamming:

Download fake "telegram.exe" and starting the executable with argument "Hahahahaha, you seen this??" . The argument could be used like this "Hahahahaha, you seen this??[PAYLOAD_URL]".

![image](/images/malware-analysis/eternity-worm/21.png)

### 2 - Infect Files:

Enumerate directories (Desktop - Pictures - Documents) and get list of files from it.

![image](/images/malware-analysis/eternity-worm/21.png)

For each file it checks its extension by hash, and if it fit any of the following extensions it will be infected:
```

    png - exe - txt - zip - xlsx - bat - mp3 - mp4 - py - pyw - docx - jar - pdf - pptx

```

![image](/images/malware-analysis/eternity-worm/22.png)

Create a loader executable in the Temp directory which will contain:

- Stub that will decrypt and execute resources files.
- Encrypted code of the original file.
- Encrypted code of "kingz.exe" and decryption key for it.


![image](/images/malware-analysis/eternity-worm/23.png)

- Change the icon of the file to simulate original file icon.
- Copy original file (Created, Modified,Accessed) time and date to the fake file.
- Copy the fake file to original file place, and spoofs the extension using the RTLO (Right-to-Left Override) technique. This will make the file appear with original file extension while its using "scr" extension, which is a Screen saver that will execute the code.

![image](/images/malware-analysis/eternity-worm/24.png)

The result will be an executable similar to stage 1 loader, that will execute the original file and the "kingz.exe" executable.

![image](/images/malware-analysis/eternity-worm/25.png)

### 3 - Infect Drives Files:

Infect removable drives only, by infecting the files the same way mentioned previously.

![image](/images/malware-analysis/eternity-worm/26.png)

### 4 - Infect Python interpreter:

Infect Python OS module by adding base64 code at the beginning or the end of the file, which will download "kingz.exe" file.

![image](/images/malware-analysis/eternity-worm/27.png)

![image](/images/malware-analysis/eternity-worm/28.png)

![image](/images/malware-analysis/eternity-worm/29.png)

### 5 - Infect Cloud Directories:

Get files from directories (Dropbox - OneDrive) and infect them the same way mentioned previously.

![image](/images/malware-analysis/eternity-worm/30.png)

### 6 - Create discord spam

Retrieve the username with a GET request to "hxxps[://]discord[.]com/api/users/@me", which return a JSON and then retrieving the value from the field "username#" and value of the field "discriminator", the channels are retrieved with a request to"hxxps[://]discord[.]com/api/users/@me/channels". Then iterates the list of IDs, and for each one, it will make a POST request to "hxxps[://]discord[.]com/api/v9/channels/{0}/messages", using the ID and the content of the message which is: "Hahahahaha, you seen this??[PAYLOAD_URL]".

![image](/images/malware-analysis/eternity-worm/31.png)

![image](/images/malware-analysis/eternity-worm/32.png)

## Features:

```
    Geo-Fencing.
    Anti-Repeating.
    Obfuscation.
    Anti-VM.
    Anti-TaskManager.
    Anti-Debugging.
    Set Critical Process.
    Elevate Privileges.
    Self Destruct.
    extension spoofing
    Icon spoofing.
    Discord spamming.
    Telegram spamming.
    Python Interpreter Infection.
    User directories infection.
    Cloud directories infection.
    Removable drives infection.
```

## Yara Rule:

```
rule EternityWorm {
    meta:
        description = "Eternity Worm - file worm-loader, worm_obfuscated.exe, worm_deobfuscated, DarkBuilder.dll"
        author = "0xM3H51N"
        date = "2022-11-20"
        hash1 = "05995179711b59173a99521e280bded1586b35e7110aadfc68d0c95a29812fc"
        hash2 = "4bac627e70d01fde25794efefbb337a7008ddb0cc88ddb1cc71bbe8bd73f3"
        hash3 = "22d656a93589f45d7c71039fe808541105dc6927bca733933b67fa4843863f3"
        hash4 = "4dd7dca60e36638a0ab5362384f0009031998fd4e6e055d872049f319153300c"

    strings:
        $s1 = "DarkBuilder.dll" fullword wide
        $s2 = "D:\\Projects\\DarkBuilder\\JoinerStub\\obj\\Release\\JoinerStub.pdb" fullword ascii
        $s3 = "DarkBuilder" fullword wide
        $s4 = "JoinerStub.exe" fullword wide
        $s5 = "DarkBuilder.IconInjector" fullword ascii
        $s6 = "DarkBuilder_ProcessedByFody" fullword ascii
        $s7 = "get_spoofedExtension" fullword ascii
        $s8 = "ElevatePrevileges_Runtime" fullword ascii
        $s9 = "https://github.com/LightM4n" fullword wide
        $s10 = "DarkBuilder.ExtensionSpoofer" fullword wide
        $s11 = "Evader" fullword wide
        $s12 = "SignatureInjector" fullword wide
        $s13 = "costura.darkbuilder.dll.compressed" fullword ascii
        $s14 = "@LightM4n"

    condition:
        uint16(0) == 0x5a4d and
        hash.sha256(0, filesize) == "856ef7f6111594731015621e730d9713ae5982473280703bd3c7de5ba8884767" or
        hash.sha256(0, filesize) == "05995179711b59173a99521e280bded1586b35e7110aadfc68d0c95a29812fc" or
        hash.sha256(0, filesize) == "22d656a93589f45d7c71039fe808541105dc6927bca733933b67fa4843863f3" or
        hash.sha256(0, filesize) == "4dd7dca60e36638a0ab5362384f0009031998fd4e6e055d872049f319153300c" or
        any of them
}
```
